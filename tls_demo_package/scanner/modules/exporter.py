"""Export scan results to multiple formats (JSON, CSV, Markdown)."""

from __future__ import annotations

import csv
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

try:
    from jinja2 import Template
except ImportError:
    Template = None

MARKDOWN_TEMPLATE = """# TLS Security Scan Report

**Report Generated**: {{ timestamp }}

---

## Executive Summary

| Metric | Count |
|--------|-------|
| **Total Targets** | {{ total_targets }} |
| **ðŸ”´ Critical Issues** | {{ critical_count }} |
| **ðŸŸ  High Issues** | {{ high_count }} |
| **ðŸŸ¡ Medium Issues** | {{ medium_count }} |
| **ðŸ”µ Low Issues** | {{ low_count }} |

---

## Risk Overview

{% if critical_count > 0 %}
### âš ï¸ CRITICAL FINDINGS
Your environment has **{{ critical_count }}** critical security issues that require immediate remediation.

{% endif %}

{% if high_count > 0 %}
### âš ï¸ HIGH PRIORITY ISSUES  
There are **{{ high_count }}** high-severity findings that should be addressed promptly.

{% endif %}

{% if medium_count == 0 and high_count == 0 and critical_count == 0 %}
### âœ… No Critical Issues Found
Your scanned targets are in good security posture.

{% endif %}

---

## Detailed Findings

{% for result in results %}
### ðŸŒ {{ result.url }}

{% if result.error %}
**Status**: âŒ ERROR  
**Error Message**: {{ result.error }}

---
{% else %}

**Overall Risk Level**: {{ result.risk }}  
**HTTP Status**: {{ result.status }}  
**Risk Score**: {{ result.score }}/100

{% if not result.findings %}
âœ… **No security findings detected for this target.**

{% else %}

#### Identified Issues

{% for finding in result.findings %}
**[{{ finding.severity }}]** `{{ finding.rule }}`
- {{ finding.detail }}

{% endfor %}

#### Recommendations

{% for suggestion in result.suggestions %}
âœ“ {{ suggestion }}

{% endfor %}

{% endif %}

#### TLS/SSL Information

{% if result.tls.error %}
- **Status**: âŒ {{ result.tls.error }}

{% else %}
| Property | Value |
|----------|-------|
| **TLS Version** | {{ result.tls.protocol }} |
| **Cipher Suite** | {{ result.tls.cipher.name }} |
| **Cipher Strength** | {{ result.tls.cipher.bits }} bits |
{% if result.tls.certificate %}
| **Subject** | {{ result.tls.certificate.subject }} |
| **Issuer** | {{ result.tls.certificate.issuer }} |
| **Expires** | {{ result.tls.certificate.not_after }} |
{% if result.tls.certificate.subject_alt_names %}
| **SANs** | {{ result.tls.certificate.subject_alt_names }} |
{% endif %}
{% endif %}

{% endif %}

#### HTTP Security Headers

| Header | Value |
|--------|-------|
{% for key, value in result.headers.items() %}
| **{{ key }}** | {{ value }} |
{% endfor %}

---

{% endif %}
{% endfor %}

## Summary & Next Steps

### Critical Actions Required
{% if critical_count > 0 %}
- Address all **{{ critical_count }}** critical findings immediately
- Test changes in staging environment before production deployment
- Consider engaging security team for peer review
{% else %}
- No critical actions required at this time
{% endif %}

### Recommended Next Steps
1. Review all findings against your security policy
2. Prioritize fixes based on CVSS score and business impact
3. Implement recommended security headers
4. Schedule regular security audits (quarterly or after major changes)
5. Monitor certificate expiration dates

---

**Report Generated By**: TLS Security Scanner  
**Generated At**: {{ timestamp }}  
**For Questions**: Contact your security team
"""


class ReportExporter:
    """Export scan results to various formats."""
    
    @staticmethod
    def to_json(results: List[Dict], filepath: Optional[str] = None) -> str:
        """Export results to JSON format."""
        data = {
            "timestamp": datetime.now().isoformat(),
            "total_targets": len(results),
            "results": results,
        }
        json_str = json.dumps(data, indent=2, ensure_ascii=False)
        
        if filepath:
            Path(filepath).write_text(json_str, encoding="utf-8")
        
        return json_str
    
    @staticmethod
    def to_csv(results: List[Dict], filepath: str) -> str:
        """Export results to CSV format."""
        rows = []
        
        for result in results:
            findings = result.get("findings") or []
            row = {
                "URL": result.get("url", ""),
                "Risk": result.get("risk", ""),
                "Score": result.get("score", ""),
                "HTTP_Status": result.get("status", ""),
                "TLS_Version": result.get("tls", {}).get("protocol", "") if isinstance(result.get("tls"), dict) else "",
                "Cipher": result.get("tls", {}).get("cipher", {}).get("name", "") if isinstance(result.get("tls"), dict) else "",
                "Cipher_Bits": str(result.get("tls", {}).get("cipher", {}).get("bits", "")) if isinstance(result.get("tls"), dict) else "",
                "Findings_Count": len(findings),
                "Critical_Issues": sum(1 for f in findings if isinstance(f, dict) and f.get("severity") == "CRITICAL"),
                "High_Issues": sum(1 for f in findings if isinstance(f, dict) and f.get("severity") == "HIGH"),
                "Medium_Issues": sum(1 for f in findings if isinstance(f, dict) and f.get("severity") == "MEDIUM"),
                "Findings_Summary": "; ".join([f"{f.get('rule', '')}" for f in findings if isinstance(f, dict)][:5]),
            }
            rows.append(row)
        
        if rows:
            fieldnames = rows[0].keys()
            with open(filepath, "w", newline="", encoding="utf-8") as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerows(rows)
        
        return filepath
    
    @staticmethod
    def to_markdown(results: List[Dict], filepath: Optional[str] = None) -> str:
        """Export results to Markdown format."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        critical_count = sum(1 for r in results if r.get("risk") == "CRITICAL")
        high_count = sum(1 for r in results if r.get("risk") == "HIGH")
        medium_count = sum(1 for r in results if r.get("risk") == "MEDIUM")
        low_count = sum(1 for r in results if r.get("risk") == "LOW")
        
        # Sanitize results
        safe_results = []
        for r in results:
            safe_r = dict(r)
            if not isinstance(safe_r.get("findings"), list):
                safe_r["findings"] = []
            if not isinstance(safe_r.get("headers"), dict):
                safe_r["headers"] = {}
            if not isinstance(safe_r.get("suggestions"), list):
                safe_r["suggestions"] = []
            safe_results.append(safe_r)
        
        if Template:
            template = Template(MARKDOWN_TEMPLATE)
            md_str = template.render(
                timestamp=timestamp,
                total_targets=len(results),
                critical_count=critical_count,
                high_count=high_count,
                medium_count=medium_count,
                low_count=low_count,
                results=safe_results,
            )
        else:
            md_str = f"""# TLS Security Scan Report

Generated: {timestamp}

## Summary
- Total Targets: {len(results)}
- Critical Issues: {critical_count}
- High Issues: {high_count}
- Medium Issues: {medium_count}
- Low Issues: {low_count}
"""
        
        if filepath:
            Path(filepath).write_text(md_str, encoding="utf-8")
        
        return md_str


def export_results(
    results: List[Dict],
    output_dir: str = "./reports",
    formats: List[str] = None,
) -> Dict[str, str]:
    """Export results to multiple formats at once.
    
    Args:
        results: List of scan result dictionaries
        output_dir: Directory to save exported files
        formats: List of formats to export (json, csv, markdown)
                If None, defaults to all formats
    
    Returns:
        Dictionary mapping format names to file paths
    """
    if formats is None:
        formats = ["json", "csv", "markdown"]
    
    # Ensure formats is a list
    if not isinstance(formats, list):
        formats = [formats] if isinstance(formats, str) else ["json", "csv", "markdown"]
    
    # Normalize format names to lowercase
    formats = [fmt.lower() for fmt in formats]
    
    output_dir_path = Path(output_dir)
    output_dir_path.mkdir(parents=True, exist_ok=True)
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    exported_files = {}
    
    exporter = ReportExporter()
    
    if "json" in formats:
        json_file = output_dir_path / f"report_{timestamp}.json"
        exporter.to_json(results, str(json_file))
        exported_files["json"] = str(json_file)
    
    if "csv" in formats:
        csv_file = output_dir_path / f"report_{timestamp}.csv"
        exporter.to_csv(results, str(csv_file))
        exported_files["csv"] = str(csv_file)
    
    if "markdown" in formats:
        md_file = output_dir_path / f"report_{timestamp}.md"
        exporter.to_markdown(results, str(md_file))
        exported_files["markdown"] = str(md_file)
    
    return exported_files
